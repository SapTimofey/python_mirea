# n2_1
print([0xfor _ in 'abc'])
# Выведет [15], так как 0xfor python видит как [0xf or _ in 'abc'] и если
# в левой части оператора or стоит True (0xf), то до правой части оператора
# or не доходит, поэтому возвращается 0xf без ошибки.


# n2_2
a = 1
b = 1
c = 300000  # проверено в Python 3.11
d = 300000
print(a is b, c is d)  # True True

a, b = 'py', 'py'
c = ''.join(['p', 'y'])
print(a is b, a == c, a is c)  # True True False

"""
В Python существует кэширование (caching) небольших целых чисел в диапазоне от -5 до 256. Таким образом, 
для малых целых чисел переменные будут указывать на один и тот же объект в памяти. В вашем случае a и b равны 1, 
что входит в этот диапазон, поэтому a is b возвращает True.

Однако для больших целых чисел, таких как 300000, кэширование не применяется, и 
каждая переменная будет указывать на свой собственный объект в памяти. Поэтому c is d возвращает False.
"""

# n2_3
i = 0
print(['much','code','wow'][i])  # 24 символа
print('muchcodewow'[i:4])  # much


# n2_4
lst = ['a', 'b', 'c']
lst += 'd'  # Эквивалентно lst.extend('d')
print(lst)

# lst = lst + 'd'  # Мы пытаемся сложить список и строку, что вызовет ошибку, так как оператор + не определен для этих типов
# print(lst)

# lst += 42  # Мы пытаемся добавить число к списку, что вызовет ошибку, так как int не является итерируемым объектом
# print(lst)  # Ошибка?!
